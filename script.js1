%%writefile /content/script/script.js
import axios from "axios";
import readline from "readline";
import fs from 'fs';
import ProgressBar from 'progress';
import { exec } from 'child_process';

const nombre = `
                ██████╗░██╗██╗░░░░░██╗░░░████████╗██╗░░░██╗
                ██╔══██╗██║██║░░░░░██║░░░╚══██╔══╝██║░░░██║
                ██████╦╝██║██║░░░░░██║░░░░░░██║░░░╚██╗░██╔╝
                ██╔══██╗██║██║░░░░░██║░░░░░░██║░░░░╚████╔╝░
                ██████╦╝██║███████╗██║██╗░░░██║░░░░░╚██╔╝░░
                ╚═════╝░╚═╝╚══════╝╚═╝╚═╝░░░╚═╝░░░░░░╚═╝░░░
`;

axios.defaults.headers = {
    referer: 'https://www.bilibili.tv/',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
};

const descargarVideoYAudio = async (videoUrls, audioUrl, directorioDestino = '.') => {
    if (!videoUrls || videoUrls.length === 0 || !audioUrl) {
        console.log('Video or audio URLs missing.');
        return null;
    }

    const nombreArchivoVideoFinal = `${directorioDestino}/${Math.floor(Math.random() * 1000000)}_video.m4v`;
    const nombreArchivoAudio = `${directorioDestino}/${Math.floor(Math.random() * 1000000)}_audio.mp4`;

    // Download audio
    await descargarArchivo(audioUrl, nombreArchivoAudio);

    // Handle multiple video parts
    const partFiles = [];
    for (const [index, videoUrl] of videoUrls.entries()) {
        const nombreArchivoVideoPart = `${directorioDestino}/part_${index + 1}_${Math.floor(Math.random() * 1000000)}.m4v`;
        await descargarArchivo(videoUrl, nombreArchivoVideoPart);
        partFiles.push(nombreArchivoVideoPart);
    }

    // Concatenate video parts if multiple
    if (partFiles.length > 1) {
        const concatList = partFiles.map(f => `file '${f}'`).join('\n');
        const concatFile = `${directorioDestino}/concat.txt`;
        fs.writeFileSync(concatFile, concatList);
        await ejecutarComandoShell(`ffmpeg -f concat -safe 0 -i ${concatFile} -c copy ${nombreArchivoVideoFinal}`);
        await eliminarArchivo(concatFile);
        for (const partFile of partFiles) {
            await eliminarArchivo(partFile);
        }
    } else {
        // Single part: rename the downloaded file
        fs.renameSync(partFiles[0], nombreArchivoVideoFinal);
    }

    // Merge video and audio
    const nombreArchivoFinal = `${directorioDestino}/${Math.floor(Math.random() * 1000000)}_final.mp4`;
    const comandoFFmpeg = `ffmpeg -i ${nombreArchivoVideoFinal} -i ${nombreArchivoAudio} -vcodec copy -acodec copy -f mp4 ${nombreArchivoFinal}`;
    await ejecutarComandoShell(comandoFFmpeg);

    console.log(`Files merged as: ${nombreArchivoFinal}\n`);

    await eliminarArchivo(nombreArchivoVideoFinal);
    await eliminarArchivo(nombreArchivoAudio);

    console.log('Temporary video and audio files deleted.');
    return nombreArchivoFinal;
};

const descargarArchivo = async (url_archivo, nombre_archivo, retries = 3) => {
    try {
        const response = await axios.get(url_archivo, {
            responseType: 'stream',
            timeout: 600000,
            headers: {
                'Referer': 'https://www.bilibili.tv/',
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            }
        });
        const totalBytes = parseInt(response.headers['content-length'], 10) || 1000000;
        const bar = new ProgressBar(`Downloading ${nombre_archivo} [:bar] :percent :etas`, {
            complete: '=',
            incomplete: ' ',
            width: 20,
            total: totalBytes
        });

        const writableStream = fs.createWriteStream(nombre_archivo);
        response.data.on('data', (chunk) => {
            bar.tick(chunk.length);
        });
        response.data.pipe(writableStream);

        await new Promise((resolve, reject) => {
            writableStream.on('finish', resolve);
            writableStream.on('error', reject);
        });

        console.log(`File downloaded as: ${nombre_archivo}\n`);
        return nombre_archivo;
    } catch (error) {
        if (retries > 0) {
            console.log(`Retrying download (${retries} attempts left): ${error.message}`);
            return descargarArchivo(url_archivo, nombre_archivo, retries - 1);
        }
        console.error(`Error during file download: ${error.message}`);
        return null;
    }
};

const eliminarArchivo = async (nombreArchivo) => {
    try {
        await fs.promises.unlink(nombreArchivo);
    } catch (error) {
        console.log(`Error deleting file ${nombreArchivo}: ${error.message}`);
    }
};

const ejecutarComandoShell = async (comando) => {
    return new Promise((resolve, reject) => {
        exec(comando, (error, stdout, stderr) => {
            if (error) {
                console.error(`Error executing command: ${error.message}`);
                reject(error);
            } else {
                resolve(stdout);
            }
        });
    });
};

const processUrlsFromFile = async (filePath) => {
    const directorioDestino = '/content/drive/MyDrive/BilibiliDownloads';
    try {
        if (!fs.existsSync(directorioDestino)) {
            fs.mkdirSync(directorioDestino, { recursive: true });
        }
    } catch (error) {
        console.error(`Error creating directory ${directorioDestino}: ${error.message}`);
        return false;
    }

    const logFile = '/content/drive/MyDrive/BilibiliDownloads/download_log.txt';

    try {
        const data = fs.readFileSync(filePath, 'utf-8');
        const urlData = JSON.parse(data);
        const videoUrls = urlData.videoUrls || [];
        const audioUrl = urlData.audioUrl || '';
        const sourceUrl = urlData.sourceUrl || 'unknown';

        if (fs.existsSync(logFile) && fs.readFileSync(logFile, 'utf-8').includes(sourceUrl)) {
            console.log(`Source URL ${sourceUrl} already downloaded. Skipping.`);
            return true;
        }

        const result = await descargarVideoYAudio(videoUrls, audioUrl, directorioDestino);
        if (result) {
            fs.appendFileSync(logFile, `${sourceUrl} -> ${result}\n`);
            return true;
        }
        return false;
    } catch (error) {
        console.error(`Error processing URLs from ${filePath}: ${error.message}`);
        return false;
    }
};

console.log(nombre);
console.log('                     https://github.com/jjaruna \n');

const urlFile = '/content/script/urls.json';
if (fs.existsSync(urlFile)) {
    processUrlsFromFile(urlFile).then((success) => {
        console.log(success ? 'Processing completed.' : 'Processing failed.');
        process.exit(success ? 0 : 1);
    });
} else {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    const promptForUrls = () => {
        rl.question('Enter video URLs (comma-separated) or "exit" to quit: ', (videoUrlsInput) => {
            if (videoUrlsInput.toLowerCase() === 'exit') {
                rl.close();
                return;
            }
            rl.question('Enter audio URL: ', (audioUrl) => {
                rl.question('Enter source video URL (for logging): ', (sourceUrl) => {
                    const videoUrls = videoUrlsInput.split(',').map(url => url.trim()).filter(url => url);
                    const urlData = { videoUrls, audioUrl, sourceUrl };
                    fs.writeFileSync(urlFile, JSON.stringify(urlData, null, 2));
                    processUrlsFromFile(urlFile).then(() => promptForUrls());
                });
            });
        });
    };

    rl.on('error', (err) => {
        console.error(`Readline error: ${err.message}`);
        rl.close();
    });

    rl.on('SIGINT', () => {
        console.log('\nCaught interrupt signal. Exiting.');
        rl.close();
    });

    rl.on('close', () => {
        console.log('Exiting program.');
        process.exit(0);
    });

    promptForUrls();
}
